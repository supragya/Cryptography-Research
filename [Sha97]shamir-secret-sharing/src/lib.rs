use num_traits::One;
use num_traits::Zero;
use polynomial::Polynomial;
use rand::RngCore;
use rand::SeedableRng;
use simba::scalar::ComplexField;
use std::fmt::Debug;
use std::ops::Mul;
use std::ops::Sub;

/// Shamir's secret sharing is an ideal and perfect
/// (k, n)-threshold scheme based on polynomial interpolation.
/// Here, `n` is the number of secret parts generated by the
/// scheme, knowledge of any `k` of which can reconstruct original
/// secret
pub struct ShamirSecret<T, const K: usize, const N: usize> {
    /// The underlying secret value to be broken up
    /// into secret "parts"
    secret: T,
}

/// A share of secret of form `(x, f(x))` where `x` is "evalutation
/// point" and `f(x)` is "opening"
#[derive(Debug, Clone)]
pub struct SecretShare<T> {
    pub evaluation_point: T,
    pub opening: T,
}

impl<T> SecretShare<T>
where
    T: Clone,
{
    pub fn into_tuple(&self) -> (T, T) {
        (self.evaluation_point.clone(), self.opening.clone())
    }
}

impl<T, const K: usize, const N: usize> ShamirSecret<T, K, N>
where
    T: From<u32> + Debug + Clone + Zero + One + Mul<Output = T> + Sub<Output = T> + ComplexField,
{
    /// Generates a Shamir's secret generator for a given
    /// secret value `secret` such that any `k` of `n` shares
    /// generated can reconstruct the `secret` back
    pub fn new_from_secret(secret: T) -> Self {
        assert!(K < N);
        Self { secret }
    }

    /// Generate a Shamir's secret from `K` shares
    pub fn new_from_shares(shares: [SecretShare<T>; K]) -> Self {
        let evaluations: Vec<(T, T)> = shares.into_iter().map(|s| s.into_tuple()).collect();
        let reconstructed_poly = Polynomial::new_from_evals(&evaluations);

        Self {
            secret: reconstructed_poly.eval(T::zero()),
        }
    }

    /// Get the underlying secret value
    pub fn get_secret(&self) -> T {
        self.secret.clone()
    }

    /// Generate `n` secret shares
    pub fn generate_secret_shares(&self) -> [SecretShare<T>; N] {
        // first, generate a polynomial of form `f(x) = s + a*x + b*x^2 + ...`
        // where `s` is the encoded secret value, `a`, `b`... are random
        // coefficients and degree of `f(x)` is `K-1`.
        let mut rng = rand_chacha::ChaCha8Rng::seed_from_u64(0);

        let coefficients: Vec<T> = vec![self.secret.clone()]
            .into_iter()
            .chain((1..K).map(|_| T::from(rng.next_u32() % 100)))
            .collect();

        let polynomial = Polynomial::new_from_coeffs(&coefficients);

        let secret_shares: Vec<SecretShare<T>> = (0..N)
            .map(|_| {
                let evaluation_point = T::from(rng.next_u32() % 80);
                let opening = polynomial.eval(evaluation_point.clone());
                SecretShare {
                    evaluation_point,
                    opening,
                }
            })
            .collect();

        secret_shares
            .try_into()
            .expect("slice with incorrect length")
    }
}

#[cfg(test)]
mod tests {
    use crate::ShamirSecret;

    #[test]
    fn shamir_secret_sharing_f64() {
        let secret_value = 2;

        let shares = ShamirSecret::<f64, 2, 4>::new_from_secret(secret_value.into())
            .generate_secret_shares();

        let reconstructed_from_shares =
            ShamirSecret::<f64, 2, 4>::new_from_shares([shares[0].clone(), shares[2].clone()]);

        assert_eq!(reconstructed_from_shares.get_secret() as i32, secret_value)
    }
}
