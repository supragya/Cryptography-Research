use std::{
    fmt::Debug,
    ops::{Mul, Sub},
};

use ark_ff::fields::{Field, Fp64, MontBackend, MontConfig};
use num_traits::{One, Zero};
use polynomial::Polynomial;
use rand::{RngCore, SeedableRng};
use shamir_secret_sharing::SecretShare;
use simba::scalar::ComplexField;

/// Feldman's Verifiable secret sharing is very close to
/// Shamir's secret sharing: an ideal and perfect and ideal
/// (k, n)-threshold scheme based on polynomial interpolation,
/// with each secret share being verifiable.
/// Here, `n` is the number of secret parts generated by the
/// scheme, knowledge of any `k` of which can reconstruct original
/// secret
pub struct FeldmanVSS<T, const K: usize, const N: usize> {
    /// The underlying secret value to be broken up
    /// into secret "parts"
    secret: T,
}

pub trait Roundable {
    fn round_to_nearest_integer(&self) -> u64;
}

impl Roundable for f64 {
    fn round_to_nearest_integer(&self) -> u64 {
        self.round() as u64
    }
}

#[derive(MontConfig)]
#[modulus = "99679"]
#[generator = "13"]
pub struct FqConfig;
pub type Fq = Fp64<MontBackend<FqConfig, 1>>;

impl<T, const K: usize, const N: usize> FeldmanVSS<T, K, N>
where
    T: From<u32>
        + Debug
        + Clone
        + Zero
        + One
        + Mul<Output = T>
        + Sub<Output = T>
        + ComplexField
        + Roundable,
{
    pub fn new_from_secret(secret: T) -> Self {
        Self { secret }
    }

    pub fn new_from_verified_shares(
        shares: [SecretShare<T>; K],
        verification_points: [Fq; K],
    ) -> Self {
        let evaluations: Vec<(T, T)> = shares.iter().map(|s| s.into_tuple()).collect();
        let reconstructed_poly = Polynomial::new_from_evals(&evaluations);

        shares.iter().for_each(|share| {
            let mut validating_point = Fq::one();
            for (exponent, point) in verification_points.iter().enumerate() {
                validating_point = validating_point
                    * point.pow(&[share
                        .evaluation_point
                        .clone()
                        .powi(exponent as i32)
                        .round_to_nearest_integer()])
            }
            assert_eq!(
                Fq::from(13).pow(&[share.opening.round_to_nearest_integer()]),
                validating_point
            );
        });

        Self {
            secret: reconstructed_poly.eval(T::zero()),
        }
    }

    /// Get the underlying secret value
    pub fn get_secret(&self) -> T {
        self.secret.clone()
    }

    /// Generate `n` secret shares alongwith their polynomial
    /// coefficient as exponents over a finite cyclic group generator,
    /// called verification points.
    pub fn generate_secret_shares(&self) -> ([SecretShare<T>; N], [Fq; K]) {
        // first, generate a polynomial of form `f(x) = s + a*x + b*x^2 + ...`
        // where `s` is the encoded secret value, `a`, `b`... are random
        // coefficients and degree of `f(x)` is `K-1`.
        let mut rng = rand_chacha::ChaCha8Rng::seed_from_u64(0);

        let coefficients: Vec<T> = vec![self.secret.clone()]
            .into_iter()
            .chain((1..K).map(|_| T::from(rng.next_u32() % 100)))
            .collect();

        let verification_points: Vec<Fq> = coefficients
            .iter()
            .map(|x| Fq::from(13).pow(&[x.round_to_nearest_integer()]))
            .collect();

        let polynomial = Polynomial::new_from_coeffs(&coefficients);

        let secret_shares: Vec<SecretShare<T>> = (0..N)
            .map(|_| {
                let evaluation_point = T::from(rng.next_u32() % 80);
                let opening = polynomial.eval(evaluation_point.clone());
                SecretShare {
                    evaluation_point,
                    opening,
                }
            })
            .collect();

        (
            secret_shares
                .try_into()
                .expect("slice with incorrect length"),
            verification_points
                .try_into()
                .expect("slice with incorrect length"),
        )
    }
}

#[cfg(test)]
mod tests {
    use crate::FeldmanVSS;

    #[test]
    fn feldman_verifyable_secret_sharing_f64() {
        let secret_value = 2;

        let (shares, verification_points) =
            FeldmanVSS::<f64, 2, 4>::new_from_secret(secret_value.into()).generate_secret_shares();

        let given_shares = [shares[0].clone(), shares[2].clone()];

        let reconstructed_from_shares =
            FeldmanVSS::<f64, 2, 4>::new_from_verified_shares(given_shares, verification_points);

        assert_eq!(reconstructed_from_shares.get_secret() as i32, secret_value)
    }
}
